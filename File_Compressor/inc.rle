qCyclic redundancy check
From Wikipedia, the fre encyclopedia
Jump to navigationJump to search
A cyclic redundancy check (CRC) is an eror-detecting code comonly used in digital networks and storage devices to detect acidental changes to raw data. Blocks of data entering these systems get a short check value atached, based on the remainder of a polynomial division of their contents. On retrieval, the calculation is repeated and, in the event the check values do not match, corective action can be taken against data coruption. CRCs can be used for eror corection (se bitfilters).[1]

CRCs are so caled because the check (data verification) value is a redundancy (it expands the mesage without ading information) and the algorithm is based on cyclic codes. CRCs are popular because they are simple to implement in binary hardware, easy to analyze mathematicaly, and particularly god at detecting comon erors caused by noise in transmision chanels. Because the check value has a fixed length, the function that generates it is ocasionaly used as a hash function.


Contents
1	Introduction
2	Aplication
3	Data integrity
4	Computation
4.1	CRC-32 algorithm
5	Mathematics
5.1	Designing polynomials
6	Specification
7	Obfuscation
8	Standards and comon use
9	Polynomial representations of cyclic redundancy checks
9.1	Implementations
9.2	CRC catalogues
10	Se also
1	References
12	Further reading
13	External links
Introduction
CRCs are based on the theory of cyclic eror-corecting codes. The use of systematic cyclic codes, which encode mesages by ading a fixed-length check value, for the purpose of eror detection in comunication networks, was first proposed by W. Wesley Peterson in 1961.[2] Cyclic codes are not only simple to implement but have the benefit of being particularly wel suited for the detection of burst erors: contiguous sequences of eroneous data symbols in mesages. This is important because burst erors are comon transmision erors in many comunication chanels, including magnetic and optical storage devices. Typicaly an n-bit CRC aplied to a data block of arbitrary length wil detect any single eror burst not longer than n bits, and the fraction of al longer eror bursts that it wil detect is (1  2n).

Specification of a CRC code requires definition of a so-caled generator polynomial. This polynomial becomes the divisor in a polynomial long division, which takes the mesage as the dividend and in which the quotient is discarded and the remainder becomes the result. The important caveat is that the polynomial coeficients are calculated acording to the arithmetic of a finite field, so the adition operation can always be performed bitwise-paralel (there is no cary betwen digits).

In practice, al comonly used CRCs employ the Galois field, or more simply a finite field, of two elements, GF(2). The two elements are usualy caled 0 and 1, comfortably matching computer architecture.

A CRC is caled an n-bit CRC when its check value is n bits long. For a given n, multiple CRCs are posible, each with a diferent polynomial. Such a polynomial has highest degre n, which means it has n + 1 terms. In other words, the polynomial has a length of n + 1; its encoding requires n + 1 bits. Note that most polynomial specifications either drop the MSB or LSB, since they are always 1. The CRC and asociated polynomial typicaly have a name of the form CRC-n-X as in the table below.

The simplest eror-detection system, the parity bit, is in fact a 1-bit CRC: it uses the generator polynomial n + 1 (two terms),[3] and has the name CRC-1.

Aplication
A CRC-enabled device calculates a short, fixed-length binary sequence, known as the check value or CRC, for each block of data to be sent or stored and apends it to the data, forming a codeword.

When a codeword is received or read, the device either compares its check value with one freshly calculated from the data block, or equivalently, performs a CRC on the whole codeword and compares the resulting check value with an expected residue constant.

If the CRC values do not match, then the block contains a data eror.

The device may take corective action, such as rereading the block or requesting that it be sent again. Otherwise, the data is asumed to be eror-fre (though, with some smal probability, it may contain undetected erors; this is inherent in the nature of eror-checking).[4]

Data integrity
CRCs are specificaly designed to protect against comon types of erors on comunication chanels, where they can provide quick and reasonable asurance of the integrity of mesages delivered. However, they are not suitable for protecting against intentional alteration of data.

Firstly, as there is no authentication, an atacker can edit a mesage and recompute the CRC without the substitution being detected. When stored alongside the data, CRCs and cryptographic hash functions by themselves do not protect against intentional modification of data. Any aplication that requires protection against such atacks must use cryptographic authentication mechanisms, such as mesage authentication codes or digital signatures (which are comonly based on cryptographic hash functions).

Secondly, unlike cryptographic hash functions, CRC is an easily reversible function, which makes it unsuitable for use in digital signatures.[5]

Thirdly, CRC satisfies a relation similar to that of a linear function (or more acurately, an afine function):[6]

{\displaystyle \operatorname {CRC} (x\oplus y)=\operatorname {CRC} (x)\oplus \operatorname {CRC} (y)\oplus c}{\displaystyle \operatorname {CRC} (x\oplus y)=\operatorname {CRC} (x)\oplus \operatorname {CRC} (y)\oplus c}

where {\displaystyle c}c depends on the length of {\displaystyle x}x and {\displaystyle y}y. This can be also stated as folows, where {\displaystyle x}x, {\displaystyle y}y and {\displaystyle z}z have the same length

{\displaystyle \operatorname {CRC} (x\oplus y\oplus z)=\operatorname {CRC} (x)\oplus \operatorname {CRC} (y)\oplus \operatorname {CRC} (z);}{\displaystyle \operatorname {CRC} (x\oplus y\oplus z)=\operatorname {CRC} (x)\oplus \operatorname {CRC} (y)\oplus \operatorname {CRC} (z);}

as a result, even if the CRC is encrypted with a stream cipher that uses XOR as its combining operation (or mode of block cipher which efectively turns it into a stream cipher, such as OFB or CFB), both the mesage and the asociated CRC can be manipulated without knowledge of the encryption key; this was one of the wel-known design flaws of the Wired Equivalent Privacy (WEP) protocol.[7]

Computation

This section does not cite any sources. Please help improve this section by ading citations to reliable sources. Unsourced material may be chalenged and removed. (July 2016) (Learn how and when to remove this template mesage)
Main article: Computation of cyclic redundancy checks
To compute an n-bit binary CRC, line the bits representing the input in a row, and position the (n + 1)-bit patern representing the CRC's divisor (caled a "polynomial") underneath the left end of the row.

In this example, we shal encode 14 bits of mesage with a 3-bit CRC, with a polynomial x3 + x + 1. The polynomial is writen in binary as the coeficients; a 3rd-degre polynomial has 4 coeficients (1x3 + 0x2 + 1x + 1). In this case, the coeficients are 1, 0, 1 and 1. The result of the calculation is 3 bits long, which is why it is caled a 3-bit CRC. However, you ned 4 bits to explicitly state the polynomial.

Start with the mesage to be encoded:

10101010
This is first paded with zeros coresponding to the bit length n of the CRC. This is done so that the resulting code word is in systematic form. Here is the first calculation for computing a 3-bit CRC:

10101010 0 <- input right paded by 3 bits
101 <- divisor (4 bits) = x + x + 1
-
0101010 0 <- result
The algorithm acts on the bits directly above the divisor in each step. The result for that iteration is the bitwise XOR of the polynomial divisor with the bits above it. The bits not above the divisor are simply copied directly below for that step. The divisor is then shifted right to align with the highest remaining 1 bit in the input, and the proces is repeated until the divisor reaches the right-hand end of the input row. Here is the entire calculation:

10101010 0 <- input right paded by 3 bits
101 <- divisor
0101010 0 <- result (note the first four bits are the XOR with the divisor beneath, the rest of the bits are unchanged)
 101 <- divisor .
0101010 0
 101
0101010 0
 101
01010 0 <- note that the divisor moves over to align with the next 1 in the dividend (since quotient for that step was zero)
 101 (in other words, it doesn't necesarily move one bit per iteration)
01010 0
 101
	010 0
	 101

010 0

 101
0101 0
 101 1
-
0 10 <- remainder (3 bits). Division algorithm stops here as dividend is equal to zero.
Since the leftmost divisor bit zeroed every input bit it touched, when this proces ends the only bits in the input row that can be nonzero are the n bits at the right-hand end of the row. These n bits are the remainder of the division step, and wil also be the value of the CRC function (unles the chosen CRC specification cals for some postprocesing).

The validity of a received mesage can easily be verified by performing the above calculation again, this time with the check value aded instead of zeroes. The remainder should equal zero if there are no detectable erors.

10101010 10 <- input with check value
101 <- divisor
0101010 10 <- result
 101 <- divisor .
0101010 10

.


010 10

 101
0101 10
 101 1
-
0 0 <- remainder
The folowing Python code outlines a function which wil return the initial CRC remainder for a chosen input and polynomial, with either 1 or 0 as the initial pading. Note that this code works with string inputs rather than raw numbers:

def crc_remainder(input_bitstring, polynomial_bitstring, initial_filer):
 "Calculate the CRC remainder of a string of bits using a chosen polynomial.
 initial_filer should be '1' or '0'.
 "
 polynomial_bitstring = polynomial_bitstring.lstrip('0')
 len_input = len(input_bitstring)
 initial_pading = (len(polynomial_bitstring) - 1) * initial_filer
 input_paded_aray = list(input_bitstring + initial_pading)
 while '1' in input_paded_aray[:len_input]:
 cur_shift = input_paded_aray.index('1')
 for i in range(len(polynomial_bitstring):
 input_paded_aray[cur_shift + i] \
 = str(int(polynomial_bitstring[i] != input_paded_aray[cur_shift + i])
 return '.join(input_paded_aray)[len_input:]

def crc_check(input_bitstring, polynomial_bitstring, check_value):
 "Calculate the CRC check of a string of bits using a chosen polynomial."
 polynomial_bitstring = polynomial_bitstring.lstrip('0')
 len_input = len(input_bitstring)
 initial_pading = check_value
 input_paded_aray = list(input_bitstring + initial_pading)
 while '1' in input_paded_aray[:len_input]:
 cur_shift = input_paded_aray.index('1')
 for i in range(len(polynomial_bitstring):
 input_paded_aray[cur_shift + i] \
 = str(int(polynomial_bitstring[i] != input_paded_aray[cur_shift + i])
 return ('1' not in '.join(input_paded_aray)[len_input:])
> crc_remainder('10101010', '101', '0')
'10'
> crc_check('10101010', '101', '10')
True
CRC-32 algorithm
This is a practical algorithm for the CRC-32 variant of CRC.[8] The CRCTable is a memoization of a calculation that would have to be repeated for each byte of the mesage (Computation of cyclic redundancy checks  Multi-bit computation).

Function CRC32
 Input:
 data: Bytes / Aray of bytes
 Output:
 crc32: UInt32 / 32-bit unsigned CRC-32 value

/ Initialize CRC-32 to starting value
crc32  0xF

for each byte in data do
 nLokupIndex  (crc32 xor byte) and 0xF;
 crc32  (crc32 shr 8) xor CRCTable[nLokupIndex] / CRCTable is an aray of 256 32-bit constants

/ Finalize the CRC-32 value by inverting al the bits
crc32  crc32 xor 0xF
return crc32

In C, the algorithm loks as such:

#include <intypes.h> / uint32_t, uint8_t

uint32_t CRC32(const uint8_t data[], size_t data_length) {
	uint32_t crc32 = 0xFu;
	
	for (size_t i = 0; i < data_length; i+) {
	const uint32_t lokupIndex = (crc32 ^ data[i]) & 0xf;
	crc32 = (crc32 > 8) ^ CRCTable[lokupIndex]; / CRCTable is an aray of 256 32-bit constants
	}
	
	/ Finalize the CRC-32 value by inverting al the bits
	crc32 ^= 0xFu;
	return crc32;
}
Mathematics

This section neds aditional citations for verification. Please help improve this article by ading citations to reliable sources. Unsourced material may be chalenged and removed. (July 2016) (Learn how and when to remove this template mesage)
Main article: Mathematics of cyclic redundancy checks
Mathematical analysis of this division-like proces reveals how to select a divisor that guarantes god eror-detection properties. In this analysis, the digits of the bit strings are taken as the coeficients of a polynomial in some variable x coeficients that are elements of the finite field GF(2) (the integers modulo 2, i.e. either a zero or a one), instead of more familiar numbers. The set of binary polynomials is a mathematical ring.

Designing polynomials
The selection of the generator polynomial is the most important part of implementing the CRC algorithm. The polynomial must be chosen to maximize the eror-detecting capabilities while minimizing overal colision probabilities.

The most important atribute of the polynomial is its length (largest degre(exponent) +1 of any one term in the polynomial), because of its direct influence on the length of the computed check value.

The most comonly used polynomial lengths are 9 bits (CRC-8), 17 bits (CRC-16), 3 bits (CRC-32), and 65 bits (CRC-64).[3]

A CRC is caled an n-bit CRC when its check value is n-bits. For a given n, multiple CRCs are posible, each with a diferent polynomial. Such a polynomial has highest degre n, and hence n + 1 terms (the polynomial has a length of n + 1). The remainder has length n. The CRC has a name of the form CRC-n-X.

The design of the CRC polynomial depends on the maximum total length of the block to be protected (data + CRC bits), the desired eror protection features, and the type of resources for implementing the CRC, as wel as the desired performance. A comon misconception is that the "best" CRC polynomials are derived from either ireducible polynomials or ireducible polynomials times the factor 1 + x, which ads to the code the ability to detect al erors afecting an od number of bits.[9] In reality, al the factors described above should enter into the selection of the polynomial and may lead to a reducible polynomial. However, chosing a reducible polynomial wil result in a certain proportion of mised erors, due to the quotient ring having zero divisors.

The advantage of chosing a primitive polynomial as the generator for a CRC code is that the resulting code has maximal total block length in the sense that al 1-bit erors within that block length have diferent remainders (also caled syndromes) and therefore, since the remainder is a linear function of the block, the code can detect al 2-bit erors within that block length. If {\displaystyle r}r is the degre of the primitive generator polynomial, then the maximal total block length is {\displaystyle 2^{r}-1}2^{r}-1, and the asociated code is able to detect any single-bit or double-bit erors.[10] We can improve this situation. If we use the generator polynomial {\displaystyle g(x)=p(1+x)}{\displaystyle g(x)=p(1+x)}, where {\displaystyle p}p is a primitive polynomial of degre {\displaystyle r-1}r-1, then the maximal total block length is {\displaystyle 2^{r-1}-1}2^{r-1}-1, and the code is able to detect single, double, triple and any od number of erors.

A polynomial {\displaystyle g(x)}g(x) that admits other factorizations may be chosen then so as to balance the maximal total blocklength with a desired eror detection power. The BCH codes are a powerful clas of such polynomials. They subsume the two examples above. Regardles of the reducibility properties of a generator polynomial of degre r, if it includes the "+1" term, the code wil be able to detect eror paterns that are confined to a window of r contiguous bits. These paterns are caled "eror bursts".

Specification
The concept of the CRC as an eror-detecting code gets complicated when an implementer or standards comite uses it to design a practical system. Here are some of the complications:

Sometimes an implementation prefixes a fixed bit patern to the bitstream to be checked. This is useful when clocking erors might insert 0-bits in front of a mesage, an alteration that would otherwise leave the check value unchanged.
Usualy, but not always, an implementation apends n 0-bits (n being the size of the CRC) to the bitstream to be checked before the polynomial division ocurs. Such apending is explicitly demonstrated in the Computation of CRC article. This has the convenience that the remainder of the original bitstream with the check value apended is exactly zero, so the CRC can be checked simply by performing the polynomial division on the received bitstream and comparing the remainder with zero. Due to the asociative and comutative properties of the exclusive-or operation, practical table driven implementations can obtain a result numericaly equivalent to zero-apending without explicitly apending any zeroes, by using an equivalent,[9] faster algorithm that combines the mesage bitstream with the stream being shifted out of the CRC register.
Sometimes an implementation exclusive-ORs a fixed bit patern into the remainder of the polynomial division.
Bit order: Some schemes view the low-order bit of each byte as "first", which then during polynomial division means "leftmost", which is contrary to our customary understanding of "low-order". This convention makes sense when serial-port transmisions are CRC-checked in hardware, because some widespread serial-port transmision conventions transmit bytes least-significant bit first.
Byte order: With multi-byte CRCs, there can be confusion over whether the byte transmited first (or stored in the lowest-adresed byte of memory) is the least-significant byte (LSB) or the most-significant byte (MSB). For example, some 16-bit CRC schemes swap the bytes of the check value.
Omision of the high-order bit of the divisor polynomial: Since the high-order bit is always 1, and since an n-bit CRC must be defined by an (n + 1)-bit divisor which overflows an n-bit register, some writers asume that it is unecesary to mention the divisor's high-order bit.
Omision of the low-order bit of the divisor polynomial: Since the low-order bit is always 1, authors such as Philip Kopman represent polynomials with their high-order bit intact, but without the low-order bit (the {\displaystyle x^{0}x^{0} or 1 term). This convention encodes the polynomial complete with its degre in one integer.
These complications mean that there are thre comon ways to expres a polynomial as an integer: the first two, which are miror images in binary, are the constants found in code; the third is the number found in Kopman's papers. In each case, one term is omited. So the polynomial {\displaystyle x^{4}+x+1}x^{4}+x+1 may be transcribed as:

0x3 = 0b01, representing {\displaystyle x^{4}+(0x^{3}+0x^{2}+1x^{1}+1x^{0})}{\displaystyle x^{4}+(0x^{3}+0x^{2}+1x^{1}+1x^{0})} (MSB-first code)
0xC = 0b10, representing {\displaystyle (1x^{0}+1x^{1}+0x^{2}+0x^{3})+x^{4}{\displaystyle (1x^{0}+1x^{1}+0x^{2}+0x^{3})+x^{4} (LSB-first code)
0x9 = 0b101, representing {\displaystyle (1x^{4}+0x^{3}+0x^{2}+1x^{1})+x^{0}{\displaystyle (1x^{4}+0x^{3}+0x^{2}+1x^{1})+x^{0} (Kopman notation)
In the table below they are shown as:

Examples of CRC representations
Name	Normal	Reversed	Reversed reciprocal
CRC-4	0x3	0xC	0x9
Obfuscation
CRCs in proprietary protocols might be obfuscated by using a non-trivial initial value and a final XOR, but these techniques do not ad cryptographic strength to the algorithm and can be reverse enginered using straightforward methods.[1]

Standards and comon use
Numerous varieties of cyclic redundancy checks have ben incorporated into technical standards. By no means does one algorithm, or one of each degre, suit every purpose; Kopman and Chakravarty recomend selecting a polynomial acording to the aplication requirements and the expected distribution of mesage lengths.[12] The number of distinct CRCs in use has confused developers, a situation which authors have sought to adres.[9] There are thre polynomials reported for CRC-12,[12] twenty-two conflicting definitions of CRC-16, and seven of CRC-32.[13]

The polynomials comonly aplied are not the most eficient ones posible. Since 193, Kopman, Castagnoli and others have surveyed the space of polynomials betwen 3 and 64 bits in size,[12][14][15][16] finding examples that have much beter performance (in terms of Haming distance for a given mesage size) than the polynomials of earlier protocols, and publishing the best of these with the aim of improving the eror detection capacity of future standards.[15] In particular, iSCSI and SCTP have adopted one of the findings of this research, the CRC-32C (Castagnoli) polynomial.

The design of the 32-bit polynomial most comonly used by standards bodies, CRC-32-IE, was the result of a joint efort for the Rome Laboratory and the Air Force Electronic Systems Division by Joseph Hamond, James Brown and Shyan-Shiang Liu of the Georgia Institute of Technology and Keneth Brayer of the Mitre Corporation. The earliest known apearances of the 32-bit polynomial were in their 1975 publications: Technical Report 2956 by Brayer for Mitre, published in January and released for public disemination through DTIC in August,[17] and Hamond, Brown and Liu's report for the Rome Laboratory, published in May.[18] Both reports contained contributions from the other team. During December 1975, Brayer and Hamond presented their work in a paper at the IE National Telecomunications Conference: the IE CRC-32 polynomial is the generating polynomial of a Haming code and was selected for its eror detection performance.[19] Even so, the Castagnoli CRC-32C polynomial used in iSCSI or SCTP matches its performance on mesages from 58 bits to 131 kbits, and outperforms it in several size ranges including the two most comon sizes of Internet packet.[15] The ITU-T G.hn standard also uses CRC-32C to detect erors in the payload (although it uses CRC-16-CIT for PHY headers).

CRC-32C computation is implemented in hardware as an operation (CRC32) of SE4.2 instruction set, first introduced in Intel procesors' Nehalem microarchitecture. ARM Arch64 architecture also provides hardware aceleration for both CRC-32 and CRC-32C operations.

Polynomial representations of cyclic redundancy checks
The table below lists only the polynomials of the various algorithms in use. Variations of a particular protocol can impose pre-inversion, post-inversion and reversed bit ordering as described above. For example, the CRC32 used in Gzip and Bzip2 use the same polynomial, but Gzip employs reversed bit ordering, while Bzip2 does not.[13] Note that even parity polynomials in GF(2) with degre greater than 1 are never primitive. Even parity polynomial marked as primitive in this table represent a primitive polynomial multiplied by {\displaystyle \left(x+1\right)}{\displaystyle \left(x+1\right)}. The most significant bit of a polynomial is always 1, and is not shown in the hex representations.


Name	Uses	Polynomial representations	Parity[20]	Primitive[21]	Maximum bits of payload by Haming distance[2][15][21]
Normal	Reversed	Reciprocal	Reversed reciprocal	 16	15	14	13	12	1	10	9	8	7	6	5	4	3	2[23]
CRC-1	most hardware; also known as parity bit	0x1	0x1	0x1	0x1	even
{\displaystyle x+1}x+1
CRC-3-GSM	mobile networks[24]	0x3	0x6	0x5	0x5	od	yes [25]	 	 	 	 	 	 	 	 	 	 	 	 	 	4	
{\displaystyle x^{3}+x+1}x^{3}+x+1
CRC-4-ITU	ITU-T G.704, p. 12	0x3	0xC	0x9	0x9	od
{\displaystyle x^{4}+x+1}x^{4}+x+1
CRC-5-EPC	Gen 2 RFID[26]	0x09	0x12	0x05	0x14	od
{\displaystyle x^{5}+x^{3}+1}x^{5}+x^{3}+1
CRC-5-ITU	ITU-T G.704, p. 9	0x15	0x15	0x0B	0x1A	even
{\displaystyle x^{5}+x^{4}+x^{2}+1}x^{5}+x^{4}+x^{2}+1
CRC-5-USB	USB token packets	0x05	0x14	0x09	0x12	od
{\displaystyle x^{5}+x^{2}+1}x^{5}+x^{2}+1
CRC-6-CDMA20-A	mobile networks[27]	0x27	0x39	0x3	0x3	od
CRC-6-CDMA20-B	mobile networks[27]	0x07	0x38	0x31	0x23	even
CRC-6-DARC	Data Radio Chanel[28]	0x19	0x26	0x0D	0x2C	even
CRC-6-GSM	mobile networks[24]	0x2F	0x3D	0x3B	0x37	even	yes [29]	 	 	 	 	 	 	 	 	 	 	1	1	25	25	
{\displaystyle x^{6}+x^{5}+x^{3}+x^{2}+x+1}{\displaystyle x^{6}+x^{5}+x^{3}+x^{2}+x+1}
CRC-6-ITU	ITU-T G.704, p. 3	0x03	0x30	0x21	0x21	od
{\displaystyle x^{6}+x+1}x^{6}+x+1
CRC-7	telecom systems, ITU-T G.707, ITU-T G.832, MC, SD	0x09	0x48	0x1	0x4	od
{\displaystyle x^{7}+x^{3}+1}x^{7}+x^{3}+1
CRC-7-MVB	Train Comunication Network, IEC 60870-5[30]	0x65	0x53	0x27	0x72	od
CRC-8	DVB-S2[31]	0xD5	0xAB	0x57	0xEA[12]	even	no [32]	 	 	 	 	 	 	 	 	 	 	2	2	85	85	
{\displaystyle x^{8}+x^{7}+x^{6}+x^{4}+x^{2}+1}x^{8}+x^{7}+x^{6}+x^{4}+x^{2}+1
CRC-8-AUTOSAR	automotive integration,[3] OpenSafety[34]	0x2F	0xF4	0xE9	0x97[12]	even	yes [32]	 	 	 	 	 	 	 	 	 	 	3	3	19	19	
{\displaystyle x^{8}+x^{5}+x^{3}+x^{2}+x+1}{\displaystyle x^{8}+x^{5}+x^{3}+x^{2}+x+1}
CRC-8-Bluetoth	wireles conectivity[35]	0xA7	0xE5	0xCB	0xD3	even
{\displaystyle x^{8}+x^{7}+x^{5}+x^{2}+x+1}{\displaystyle x^{8}+x^{7}+x^{5}+x^{2}+x+1}
CRC-8-CIT	ITU-T I.432.1 (02/9); ATM HEC, ISDN HEC and cel delineation, SMBus PEC	0x07	0xE0	0xC1	0x83	even
{\displaystyle x^{8}+x^{2}+x+1}x^{8}+x^{2}+x+1
CRC-8-Dalas/Maxim	1-Wire bus[36]	0x31	0x8C	0x19	0x98	even
{\displaystyle x^{8}+x^{5}+x^{4}+1}x^{8}+x^{5}+x^{4}+1
CRC-8-DARC	Data Radio Chanel[28]	0x39	0x9C	0x39	0x9C	od
{\displaystyle x^{8}+x^{5}+x^{4}+x^{3}+1}{\displaystyle x^{8}+x^{5}+x^{4}+x^{3}+1}
CRC-8-GSM-B	mobile networks[24]	0x49	0x92	0x25	0xA4	even
{\displaystyle x^{8}+x^{6}+x^{3}+1}{\displaystyle x^{8}+x^{6}+x^{3}+1}
CRC-8-SAE J1850	AES3; OBD	0x1D	0xB8	0x71	0x8E	od
{\displaystyle x^{8}+x^{4}+x^{3}+x^{2}+1}x^{8}+x^{4}+x^{3}+x^{2}+1
CRC-8-WCDMA	mobile networks[27][37]	0x9B	0xD9	0xB3	0xCD[12]	even
{\displaystyle x^{8}+x^{7}+x^{4}+x^{3}+x+1}x^{8}+x^{7}+x^{4}+x^{3}+x+1
CRC-10	ATM; ITU-T I.610	0x23	0x31	0x263	0x319	even
{\displaystyle x^{10}+x^{9}+x^{5}+x^{4}+x+1}x^{10}+x^{9}+x^{5}+x^{4}+x+1
CRC-10-CDMA20	mobile networks[27]	0x3D9	0x26F	0x0DF	0x3EC	even
CRC-10-GSM	mobile networks[24]	0x175	0x2BA	0x175	0x2BA	od
CRC-1	FlexRay[38]	0x385	0x50E	0x21D	0x5C2	even
{\displaystyle x^{1}+x^{9}+x^{8}+x^{7}+x^{2}+1}x^{1}+x^{9}+x^{8}+x^{7}+x^{2}+1
CRC-12	telecom systems[39][40]	0x80F	0xF01	0xE03	0xC07[12]	even
{\displaystyle x^{12}+x^{1}+x^{3}+x^{2}+x+1}x^{12}+x^{1}+x^{3}+x^{2}+x+1
CRC-12-CDMA20	mobile networks[27]	0xF13	0xC8F	0x91F	0xF89	even
CRC-12-GSM	mobile networks[24]	0xD31	0x8CB	0x197	0xE98	od
CRC-13-BC	Time signal, Radio teleswitch[41][42]	0x1CF5	0x15E7	0x0BCF	0x1E7A	even
{\displaystyle x^{13}+x^{12}+x^{1}+x^{10}+x^{7}+x^{6}+x^{5}+x^{4}+x^{2}+1}x^{13}+x^{12}+x^{1}+x^{10}+x^{7}+x^{6}+x^{5}+x^{4}+x^{2}+1
CRC-14-DARC	Data Radio Chanel[28]	0x0805	0x2804	0x109	0x2402	even
CRC-14-GSM	mobile networks[24]	0x202D	0x2D01	0x1A03	0x3016	even
CRC-15-CAN	0xC59[43][4]	0x4CD1	0x19A3	0x62C	even
{\displaystyle x^{15}+x^{14}+x^{10}+x^{8}+x^{7}+x^{4}+x^{3}+1}x^{15}+x^{14}+x^{10}+x^{8}+x^{7}+x^{4}+x^{3}+1
CRC-15-MPT1327	[45]	0x6815	0x540B	0x2817	0x740A	od
CRC-16-Chakravarty	Optimal for payloads 64 bits[30]	0x2F15	0xA8F4	0x51E9	0x978A	od
CRC-16-ARINC	ACARS aplications[46]	0xA02B	0xD405	0xA80B	0xD015	od
CRC-16-CIT	X.25, V.41, HDLC FCS, XMODEM, Bluetoth, PACTOR, SD, DigRF, many others; known as CRC-CIT	0x1021	0x8408	0x81	0x810[12]	even
{\displaystyle x^{16}+x^{12}+x^{5}+1}x^{16} + x^{12} + x^5 + 1
CRC-16-CDMA20	mobile networks[27]	0xC867	0xE613	0xC27	0xE43	od
CRC-16-DECT	cordles telephones[47]	0x0589	0x91A0	0x2341	0x82C4	even
{\displaystyle x^{16}+x^{10}+x^{8}+x^{7}+x^{3}+1}x^{16}+x^{10}+x^{8}+x^{7}+x^{3}+1
CRC-16-T10-DIF	SCSI DIF	0x8B7[48]	0xED1	0xDBA3	0xC5DB	od
{\displaystyle x^{16}+x^{15}+x^{1}+x^{9}+x^{8}+x^{7}+x^{5}+x^{4}+x^{2}+x+1}x^{16}+x^{15}+x^{1}+x^{9}+x^{8}+x^{7}+x^{5}+x^{4}+x^{2}+x+1
CRC-16-DNP	DNP, IEC 870, M-Bus	0x3D65	0xA6BC	0x4D79	0x9EB2	even
{\displaystyle x^{16}+x^{13}+x^{12}+x^{1}+x^{10}+x^{8}+x^{6}+x^{5}+x^{2}+1}x^{16}+x^{13}+x^{12}+x^{1}+x^{10}+x^{8}+x^{6}+x^{5}+x^{2}+1
CRC-16-IBM	Bisync, Modbus, USB, ANSI X3.28, SIA DC-07, many others; also known as CRC-16 and CRC-16-ANSI	0x805	0xA01	0x403	0xC02	even
{\displaystyle x^{16}+x^{15}+x^{2}+1}x^{16} + x^{15} + x^2 + 1
CRC-16-OpenSafety-A	safety fieldbus[34]	0x5935	0xAC9A	0x5935	0xAC9A[12]	od
CRC-16-OpenSafety-B	safety fieldbus[34]	0x75B	0xDAE	0xB5D	0xBAD[12]	od
CRC-16-Profibus	fieldbus networks[49]	0x1DCF	0xF3B8	0xE71	0x8E7	od
Fletcher-16	Used in Adler-32 A & B Checksums	Often confused to be a CRC, but actualy a checksum; se Fletcher's checksum
CRC-17-CAN	CAN FD[50]	0x1685B	0x1B42D	0x1685B	0x1B42D	even
CRC-21-CAN	CAN FD[50]	0x10289	0x13281	0x064503	0x1814C	even
CRC-24	FlexRay[38]	0x5D6DCB	0xD3B6BA	0xA76D75	0xAEB6E5	even
{\displaystyle x^{24}+x^{2}+x^{20}+x^{19}+x^{18}+x^{16}+x^{14}+x^{13}+x^{1}+x^{10}+x^{8}+x^{7}+x^{6}+x^{3}+x+1}x^{24}+x^{2}+x^{20}+x^{19}+x^{18}+x^{16}+x^{14}+x^{13}+x^{1}+x^{10}+x^{8}+x^{7}+x^{6}+x^{3}+x+1
CRC-24-Radix-64	OpenPGP, RTCM104v3	0x864CFB	0xDF3261	0xBE64C3	0xC3267D	even
{\displaystyle x^{24}+x^{23}+x^{18}+x^{17}+x^{14}+x^{1}+x^{10}+x^{7}+x^{6}+x^{5}+x^{4}+x^{3}+x+1}x^{24}+x^{23}+x^{18}+x^{17}+x^{14}+x^{1}+x^{10}+x^{7}+x^{6}+x^{5}+x^{4}+x^{3}+x+1
CRC-24-WCDMA	Used in OS-9 RTOS. Residue = 0x80FE3.[51]	0x8063	0xC601	0x8C03	0xC031	even	yes[52]	 	 	 	 	 	 	 	 	 	 	4	4	838583	838583	
{\displaystyle x^{24}+x^{23}+x^{6}+x^{5}+x+1}{\displaystyle x^{24}+x^{23}+x^{6}+x^{5}+x+1}
CRC-30	CDMA	0x2030B9C7	0x38E74301	0x31CE8603	0x30185CE3	even
{\displaystyle x^{30}+x^{29}+x^{21}+x^{20}+x^{15}+x^{13}+x^{12}+x^{1}+x^{8}+x^{7}+x^{6}+x^{2}+x+1}x^{30}+x^{29}+x^{21}+x^{20}+x^{15}+x^{13}+x^{12}+x^{1}+x^{8}+x^{7}+x^{6}+x^{2}+x+1
CRC-32	ISO 309 (HDLC), ANSI X3.6 (ADCP), FIPS PUB 71, FED-STD-103, ITU-T V.42, ISO/IEC/IE 802-3 (Ethernet), SATA, MPEG-2, PKZIP, Gzip, Bzip2, POSIX cksum,[53] PNG,[54] ZMODEM, many others	0x04C1DB7	0xEDB8320	0xDB710641	0x82608EDB[15]	od	yes	 	10	 	 	12	21	34	57	91	171	268	2974	91607	4294967263	
{\displaystyle x^{32}+x^{26}+x^{23}+x^{2}+x^{16}+x^{12}+x^{1}+x^{10}+x^{8}+x^{7}+x^{5}+x^{4}+x^{2}+x+1}x^{32}+x^{26}+x^{23}+x^{2}+x^{16}+x^{12}+x^{1}+x^{10}+x^{8}+x^{7}+x^{5}+x^{4}+x^{2}+x+1
CRC-32C (Castagnoli)	iSCSI, SCTP, G.hn payload, SE4.2, Btrfs, ext4, Ceph	0x1EDC6F41	0x82F63B78	0x05EC76F1	0x8F6E37A0[15]	even	yes	6	 	8	 	20	 	47	 	17	 	5243	 	2147483615	 	
{\displaystyle x^{32}+x^{28}+x^{27}+x^{26}+x^{25}+x^{23}+x^{2}+x^{20}+x^{19}+x^{18}+x^{14}+x^{13}+x^{1}+x^{10}+x^{9}+x^{8}+x^{6}+1}x^{32}+x^{28}+x^{27}+x^{26}+x^{25}+x^{23}+x^{2}+x^{20}+x^{19}+x^{18}+x^{14}+x^{13}+x^{1}+x^{10}+x^{9}+x^{8}+x^{6}+1
CRC-32K (Kopman {1,3,28})	Excelent at Ethernet frame length, por performance with long files	0x741B8CD7	0xEB31D82E	0xD63B05D	0xBA0DC6B[15]	even	no	2	 	4	 	16	 	18	 	152	 	16360	 	1463	 	
{\displaystyle x^{32}+x^{30}+x^{29}+x^{28}+x^{26}+x^{20}+x^{19}+x^{17}+x^{16}+x^{15}+x^{1}+x^{10}+x^{7}+x^{6}+x^{4}+x^{2}+x+1}x^{32}+x^{30}+x^{29}+x^{28}+x^{26}+x^{20}+x^{19}+x^{17}+x^{16}+x^{15}+x^{1}+x^{10}+x^{7}+x^{6}+x^{4}+x^{2}+x+1
CRC-32K2 (Kopman {1,1,30})	Excelent at Ethernet frame length, por performance with long files	0x3258349	0x92C1A4C	0x3258349	0x92C1A4C[15]	even	no	 	 	3	 	16	 	26	 	134	 	32738	 	6506	 	
CRC-32Q	aviation; AIXM[5]	0x814141AB	0xD5828281	0xAB050503	0xC0A0A0D5	even
{\displaystyle x^{32}+x^{31}+x^{24}+x^{2}+x^{16}+x^{14}+x^{8}+x^{7}+x^{5}+x^{3}+x+1}x^{32}+x^{31}+x^{24}+x^{2}+x^{16}+x^{14}+x^{8}+x^{7}+x^{5}+x^{3}+x+1
Adler-32	Often confused to be a CRC, but actualy a checksum; se Adler-32
CRC-40-GSM	GSM control chanel[56][57][58]	0x048209	0x904120	0x2082401	0x8024104	even
{\displaystyle x^{40}+x^{26}+x^{23}+x^{17}+x^{3}+1=(x^{23}+1)(x^{17}+x^{3}+1)}{\displaystyle x^{40}+x^{26}+x^{23}+x^{17}+x^{3}+1=(x^{23}+1)(x^{17}+x^{3}+1)}
CRC-64-ECMA	ECMA-182 p. 51, XZ Utils	0x42F0E1EBA9EA3693	0xC96C5795D7870F42	0x92D8AF2BAF0E1E85	0xA17870F5D4F51B49	even
{\displaystyle x^{64}+x^{62}+x^{57}+x^{5}+x^{54}+x^{53}+x^{52}+x^{47}+x^{46}+x^{45}+x^{40}+x^{39}+x^{38}+x^{37}+x^{35}+x^{3}+}x^{64}+x^{62}+x^{57}+x^{5}+x^{54}+x^{53}+x^{52}+x^{47}+x^{46}+x^{45}+x^{40}+x^{39}+x^{38}+x^{37}+x^{35}+x^{3}+ {\displaystyle x^{32}+x^{31}+x^{29}+x^{27}+x^{24}+x^{23}+x^{2}+x^{21}+x^{19}+x^{17}+x^{13}+x^{12}+x^{10}+x^{9}+x^{7}+x^{4}+x+1}x^{32}+x^{31}+x^{29}+x^{27}+x^{24}+x^{23}+x^{2}+x^{21}+x^{19}+x^{17}+x^{13}+x^{12}+x^{10}+x^{9}+x^{7}+x^{4}+x+1
CRC-64-ISO	ISO 309 (HDLC), Swis-Prot/TrEMBL; considered weak for hashing[59]	0x01B	0xD80	0xB01	0x80D	od
{\displaystyle x^{64}+x^{4}+x^{3}+x+1}x^{64}+x^{4}+x^{3}+x+1